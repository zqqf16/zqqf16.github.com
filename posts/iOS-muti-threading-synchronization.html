<!DOCTYPE html>
<html lang="zh-cn">
<head>
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>
iOS 的多线程同步 |
穷折腾</title>
  <link rel="stylesheet" href="/static/css/style.css" />
  <link rel="stylesheet" href="/static/css/pygments.css" />
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.zorro.im/rss.xml" />
  <link rel="icon" type="image/png" href="/static/img/favicon.png">
</head>
<body>
    <div 
itemscope itemtype="http://schema.org/Article"
 class="page-wrap">
        <section class="main-header regular">
            <div class="vertical-container">
                <div class="wrapper clearfix">
                    <header>
                        <a href="/">
                            <h1 id="main-title">穷折腾</h1>
                            <h2 id="main-subtitle">zqqf16 的个人博客</h2>
                        </a>
                    </header>
                    <nav id="main-nav" role="navigation">
                        <a href="/" class="selected">主页</a>
                        <a href="/posts/about.html" class="">关于</a>
                        <a href="https://github.com/zqqf16">Github</a>
                    </nav>
                </div>
            </div>
        </section>
        <section class="main-content">
            
<article class="main-content">
    <div class="wrapper">
        <header class="section-header">
            <h1 itemprop="name" class="section-title">iOS 的多线程同步</h1>
            <span class="section-subtitle"><time itemprop="datePublished" content="2015-08-04" datetime="2015-08-04" pubdate="2015-08-04">2015-08-04</time></span>
        </header>
        <section itemprop="articleBody" class="post-content">
        	<blockquote>
<p>我的上一家公司有个引以为豪的技术：多核无锁，不仅避免了各种由锁带来的问题，还极大的提高了性能，所以产品性能能够在业界数一数二。
在这样的氛围影响下，我在开发的时候也很少用锁，能不用就不用。
后来去面试 iOS 开发的时候，面试官总是喜欢问有关于锁的问题，最近趁有时间就整理了一下，算是补充一下技能树吧。</p>
</blockquote>
<h2 id="mutex">互斥锁（Mutex）</h2>
<p>互斥锁是比较常用的一种锁，当一个线程试图获取被另一个线程占用的锁时，它将会被挂起，让出 CPU，直到该锁被释放。</p>
<p>在 iOS 中，互斥锁有多种实现方式：</p>
<h3 id="posix-api">POSIX Api</h3>
<p>POSIX 方式的优点是比较通用，对那些需要跨平台的 library 来说再合适不过了。</p>
<p>POSIX 中与互斥锁有关的主要有 5 个函数：</p>
<ul>
<li><code>pthread_mutex_init</code> 初始化锁</li>
<li><code>pthread_mutex_lock</code> 加锁</li>
<li><code>pthread_mutex_tylock</code> 加锁，当锁被占用时，返回 busy，不挂起线程。</li>
<li><code>pthread_mutex_unlock</code> 释放锁</li>
<li><code>pthread_mutex_destroy</code> 销毁锁</li>
</ul>
<p>例子：</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mutiThreadMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="c1">// Do something</span>

    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroyLock</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3 id="synchronized">@synchronized</h3>
<p>@synchronized 应该是用起来最简单的方式了，例如：</p>
<div class="codehilite"><pre><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mutiThreadMethod2</span>
<span class="p">{</span>
    <span class="k">@synchronized</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Do something</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>用 clang 改写一下就可以发现，其实编译器为这个语法糖做了很多工作，大致如下：</p>
<div class="codehilite"><pre><span class="c1">//...</span>

<span class="n">objc_sync_enter</span>
<span class="n">objc_exception_try_enter</span>
<span class="n">setjmp</span>
<span class="n">objc_exception_extract</span>

<span class="c1">// Do something</span>

<span class="n">objc_exception_try_exit</span>
<span class="n">objc_sync_exit</span>
<span class="c1">// ...</span>
<span class="n">objc_exception_throw</span>
<span class="c1">// ...</span>
</pre></div>


<p>可以看到做了很多与锁有关的操作，其性能不如 POSIX 方式，尽管后者难看些。</p>
<h3 id="nslock">NSLock</h3>
<div class="codehilite"><pre><span class="bp">NSLock</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

<span class="c1">// ...</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mutiThreadMethod3</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">lock</span> <span class="n">tryLock</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// Do something</span>
        <span class="c1">// ...</span>
        <span class="p">[</span><span class="n">lock</span> <span class="n">unlock</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="recursive-lock">递归锁（Recursive Lock）</h2>
<p>递归锁是互斥锁的变体，它允许一个线程在释放它之前多次获取它，并且只有在释放相同次数之后其它线程才能获取它。</p>
<div class="codehilite"><pre><span class="bp">NSRecursiveLock</span> <span class="o">*</span><span class="n">theLock</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSRecursiveLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">MyRecursiveFunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">theLock</span> <span class="n">lock</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">--</span><span class="n">value</span><span class="p">;</span>
        <span class="n">MyRecursiveFunction</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">theLock</span> <span class="n">unlock</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">MyRecursiveFunction</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>


<h2 id="read-write-lock">读写锁（Read-write Lock）</h2>
<p>读写锁把访问对象划分为<strong>读者</strong>和<strong>写者</strong>，当读写锁在<strong>读加锁</strong>状态时，所有的试图以读加锁方式对其进行加锁时，都会获得访问权限。
所有的试图以写加锁方式对其加锁的线程都将阻塞，直到所有的读锁释放。
当在<strong>写加锁</strong>状态时，所有试图对其加锁的线程都将阻塞。</p>
<p>读写锁适合读操作远大于写操作的情况。</p>
<p>在 iOS 上，读写锁得用 POSIX 方式实现。POSIX 提供的相关函数如下：</p>
<ul>
<li><code>pthread_rwlock_init</code> 初始化读写锁</li>
<li><code>pthread_rwlock_rdlock</code> 读加锁</li>
<li><code>pthread_rwlock_wrlock</code> 写加锁</li>
<li><code>pthread_rwlock_unlock</code> 释放锁</li>
<li><code>pthread_rwlock_destroy</code> 销毁锁</li>
</ul>
<p>例子：</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="kt">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span>
<span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mutiThreadWritting</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="c1">// write</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mutiThreadReadding</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="c1">// read</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="spin-lock">自旋锁（Spin Lock）</h2>
<p>自旋锁与互斥锁不同的地方在于，自旋锁是非阻塞的，当一个线程无法获取自旋锁时，会自旋，直到该锁被释放，等待的过程中线程并不会挂起。</p>
<p>它的优点是效率高，不用进行线程切换。缺点是如果一个线程霸占锁的时间过长，自旋会消耗 CPU 资源。</p>
<div class="codehilite"><pre><span class="cp">#import &lt;libkern/OSAtomic.h&gt;</span>

<span class="k">static</span> <span class="n">OSSpinLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">OS_SPINLOCK_INIT</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">mutiThreadMethod4</span>
<span class="p">{</span>
    <span class="n">OSSpinLockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="c1">// Do something</span>
    <span class="n">OSSpinLockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="distributed-lock">分布锁（Distributed Lock）</h2>
<p>严格来说，分布锁是进程间同步的工具，有点像 Unix 下的各种 lock 文件，比如 apt-get 的 “/var/lib/apt/lists/lock”。</p>
<p>它并不强制进程休眠，只是起到告知的作用。具体如何处理资源被占，完全由进程自己决定。</p>
<p>iOS 上几本用不上分布锁，在 OS X 中，可以用 <strong>NSDistributedLock</strong> 实现：</p>
<div class="codehilite"><pre><span class="n">NSDistributedLock</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDistributedLock</span> <span class="nl">lockWithPath</span><span class="p">:</span><span class="n">path</span><span class="p">];</span>

<span class="c1">// ...</span>

<span class="k">if</span> <span class="p">([</span><span class="n">lock</span> <span class="n">tryLock</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// Do something</span>
    <span class="p">[</span><span class="n">lock</span> <span class="n">unlock</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>或者，可以直接通过写 lock 文件的方式来实现。</p>
<h2 id="condition-variable">条件变量（Condition Variable）</h2>
<p>如果一个线程需要等待某一条件才能继续执行，而这个条件是由别的线程产生的，这时候只用锁就有点捉襟见肘了。要么不停的轮询，消耗资源，要么每隔一段时间查询一次，丧失了及时性。
条件变量就是为了满足这种场景而生的，它可以让一个线程等待某一条件，当条件满足时，会收到通知。
在获取条件变量并等待条件发生的过程中，也会产生多线程的竞争，所以条件变量通常会和互斥锁一起工作。</p>
<p>iOS 中，条件变量有两种实现方式：</p>
<h3 id="posix">POSIX</h3>
<p>POSIX 提供的相关函数如下：</p>
<ul>
<li><code>pthread_cond_init</code> 初始化</li>
<li><code>pthread_cond_wait</code> 等待条件</li>
<li><code>pthread_cond_broadcast</code> 发送广播，唤醒所有正在等待的线程</li>
<li><code>pthread_cond_signal</code> 发送信号，唤醒第一个线程</li>
<li><code>pthread_cond_destroy</code> 销毁</li>
</ul>
<p>例子：</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>

<span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">pthread_cond_t</span> <span class="n">condition</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condition</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="kt">void</span> <span class="nf">waitCondition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">triggerCondition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condition</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condition</span><span class="p">);</span>
</pre></div>


<h3 id="nscondition">NSCondition</h3>
<p>例子摘自 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html">Threading Programming Guide</a></p>
<div class="codehilite"><pre><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">lock</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">timeToDoWork</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">wait</span><span class="p">];</span>

<span class="n">timeToDoWork</span><span class="o">--</span><span class="p">;</span>

<span class="c1">// Do real work here.</span>

<span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">unlock</span><span class="p">];</span>
</pre></div>


<p>发送信号：</p>
<div class="codehilite"><pre><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">lock</span><span class="p">];</span>
<span class="n">timeToDoWork</span><span class="o">++</span><span class="p">;</span>
<span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">signal</span><span class="p">];</span>
<span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">unlock</span><span class="p">];</span>
</pre></div>


<h2 id="nsconditionlock">NSConditionLock</h2>
<p>NSConditionLock 跟 NSCondition 类似，但是实现机制是不一样的，所以单独列了出来。</p>
<p>例子：</p>
<p>生产者</p>
<div class="codehilite"><pre><span class="kt">id</span> <span class="n">condLock</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSConditionLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCondition</span><span class="p">:</span><span class="n">NO_DATA</span><span class="p">];</span>

<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">condLock</span> <span class="n">lock</span><span class="p">];</span>
    <span class="c1">// Add data to the queue.</span>
    <span class="p">[</span><span class="n">condLock</span> <span class="nl">unlockWithCondition</span><span class="p">:</span><span class="n">HAS_DATA</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>消费者</p>
<div class="codehilite"><pre><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">condLock</span> <span class="nl">lockWhenCondition</span><span class="p">:</span><span class="n">HAS_DATA</span><span class="p">];</span>
    <span class="c1">// Remove data from the queue.</span>
    <span class="p">[</span><span class="n">condLock</span> <span class="nl">unlockWithCondition</span><span class="p">:(</span><span class="n">isEmpty</span> <span class="o">?</span> <span class="nl">NO_DATA</span> <span class="p">:</span> <span class="n">HAS_DATA</span><span class="p">)];</span>

    <span class="c1">// Process the data locally.</span>
<span class="p">}</span>
</pre></div>


<h2 id="semaphore">信号量（Semaphore）</h2>
<p>信号量可以看成是一种特殊的互斥锁，不同的是，它可以不只有两个状态，它可以是资源的计数器。还记得《操作系统》中学过的 PV 操作么？</p>
<p>iOS 中，信号量有两种实现方式：</p>
<h3 id="posix_1">POSIX</h3>
<p>POSIX 提供的相关函数如下：</p>
<ul>
<li><code>sem_init</code> 初始化</li>
<li><code>sem_post</code> 给信号量的值加一（V 操作）</li>
<li><code>sem_wait</code> 给信号量的值减一（P 操作）</li>
<li><code>sem_getvalue</code> 返回信号量的值</li>
<li><code>sem_destroy</code> 销毁</li>
</ul>
<h3 id="gcd">GCD 信号量</h3>
<p>GCD 提供的函数如下：</p>
<ul>
<li><code>dispatch_semaphore_create</code> 创建信号量</li>
<li><code>dispatch_semaphore_signal</code> 发送信号（信号量加一，V 操作）</li>
<li><code>dispatch_semaphore_wait</code>等待信号（信号量减一，P 操作）</li>
</ul>
<p>例子：</p>
<div class="codehilite"><pre><span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
<span class="c1">// Do something</span>
<span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</pre></div>


<h2 id="barrier">栅栏／屏障（Barrier）</h2>
<p>如果一个线程需要等待另一个线程的某些操作之后才能继续执行，可以用上面所说的条件变量来实现，还有一种优雅的实现方式 —— Barrier。
形象点说，就是把线程挡在同一个 Barrier 之前，所有的线程都达到 Barrier 之后，统一放行。</p>
<p>同样，iOS 中有两种实现方式：</p>
<h3 id="posix_2">POSIX</h3>
<p>相关函数如下：
- <code>pthread_barrier_init</code> 创建 barrier
- <code>pthread_barrier_wait</code> 告知当前线程已经到达 barrier，等所有线程都告知后，会继续往下执行
- <code>pthread_barrier_destroy</code> 销毁</p>
<h3 id="dispatch-barrier">Dispatch Barrier</h3>
<p>Dispatch Barrier 的概念跟 POSIX 类似，不同的是它是针对于 GCD 异步任务的。它可以让在它之前提交的异步任务都执行完成之后再执行。</p>
<p>例子：</p>
<div class="codehilite"><pre><span class="n">dispatch_async</span><span class="p">(</span><span class="n">async_queue</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">async_queue</span><span class="p">,</span> <span class="n">block2</span><span class="p">);</span>
<span class="c1">// block3 会在 block1 和 block2 执行完成之后再执行</span>
<span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">async_queue</span><span class="p">,</span> <span class="n">block3</span><span class="p">);</span>
<span class="c1">// block4 和 block5 会在 block3 之后执行</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">async_queue</span><span class="p">,</span> <span class="n">block4</span><span class="p">);</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">async_queue</span><span class="p">,</span> <span class="n">block5</span><span class="p">);</span>
</pre></div>


<h2 id="_1">后记</h2>
<p><strong>锁</strong> 这个东西可谓 “小用怡情，滥用伤身”，用的时候一不小心就会有各种各样的问题，比如死锁，我曾经就这样写过：</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LOCK</span><span class="p">;</span>

    <span class="c1">//...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">someCondition</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">UNLOCK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>在 iOS 中，很多时候都可以用 GCD 的串行队列来避免使用锁：</p>
<div class="codehilite"><pre><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</pre></div>


<p>因为串行队列中的任务一次只能执行一个，所以就不存在资源的竞争，还能有效的避免死锁问题。</p>
<p>😄</p>
        </section>

		<meta itemprop="url" content="posts/iOS-muti-threading-synchronization.html">
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">
			<meta itemprop="name" content="zqqf16"></span>

        <div class="post-nav">
    		<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zqqf16';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

    	</div>
    </div>

</article>

        </section>
    </div>
    <footer class="main-footer">
        <div class="vertical-container">
            <div class="wrapper">
                <p class="copy">&copy; zqqf16</p>
            </div>
        </div>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-41282906-2', 'auto');
      ga('require', 'displayfeatures');
      ga('send', 'pageview');
    </script>
</body>
</html>
